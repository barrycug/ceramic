<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Map</title>
    <link rel="stylesheet" href="leaflet/leaflet.css">
    <style>
      
      #map {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      
    </style>
  </head>
  <body>
    
    <div id="map"></div>
    
    <script src="leaflet/leaflet.js"></script>
    <script>
      
      var map = new L.Map("map", {
        center: new L.LatLng(<%= LAT %>, <%= LNG %>),
        zoom: <%= ZOOM %>
      });
      
      
      // Mapnik underlay
      
      var mapnik = new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png");
      
      map.addLayer(mapnik);
      
      
      // Some simple canvas tiles
      
      var canvases = {};
      
      function tilePath(z, x, y) {
        
        return "/" + z + "/" + x + "/" + y;
        
      }
      
      function loadTile(canvas, z, x, y) {
        
        // draw "loading" overlay
        
        var context = canvas.getContext("2d");
        
        context.fillStyle = "rgba(255, 255, 255, 0.5)";
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // load a script tag
        
        var path = tilePath(z, x, y);
        
        canvases[path] = canvas;
        
        var script = document.createElement("script");
        script.src = path;
        
        document.body.appendChild(script);
        
      }
      
      // Tile data was loaded. Draw the tile and set up an
      // event listener on the canvas to dump the tile's
      // data on alt-click.
      
      function tileData(data, z, x, y) {
        
        var path = tilePath(z, x, y);
        var canvas = canvases[path];
        
        if (canvas) {
          
          renderTile(canvases[path], data);
          
          canvas.addEventListener("mousedown", function(e) {
          
            if (e.altKey)
              console.log(data, z, x, y);
          
          });
          
        }
        
      }
      
      function renderPoint(context, coordinates, hue, scale) {
        
        context.beginPath();
        
        context.arc(coordinates[0], coordinates[1], 3 / scale, 0, Math.PI * 2);
            
        context.fillStyle = "hsla(" + hue + ", 100%, 50%, 0.8)";
        context.fill();
        
      }
      
      function renderLineString(context, coordinates, hue, scale) {
        
        var i;
        
        // draw the line
      
        context.beginPath();
        
        context.moveTo(coordinates[0][0], coordinates[0][1]);
        
        for (i = 1; i < coordinates.length; i++) {
          context.lineTo(coordinates[i][0], coordinates[i][1]);
        }
          
        context.strokeStyle = "hsla(" + hue + ", 90%, 50%, 0.5)";
        context.stroke();
        
        // draw points
        
        context.beginPath();
        
        for (i = 0; i < coordinates.length; i++) {
          context.moveTo(coordinates[i][0] + 2 / scale, coordinates[i][1])
          context.arc(coordinates[i][0], coordinates[i][1], 1 / scale, 0, Math.PI * 2);
        }
        
        context.fillStyle = "#f00";
        context.fill();
        
      }
      
      function renderMultiLineString(context, coordinates, hue, scale) {
        
        var i;
        
        for (i = 0; i < coordinates.length; i++)
          renderLineString(context, coordinates[i], hue, scale);
        
      }
      
      function renderPolygon(context, coordinates, hue, scale) {
        
        var i, j, k;
        
        // draw shape
        
        context.beginPath();
        
        for (i = 0; i < coordinates.length; i++) {
        
          context.moveTo(coordinates[i][0][0], coordinates[i][0][1]);
          
          for (j = 0; j < coordinates[i].length; j++)
            context.lineTo(coordinates[i][j][0], coordinates[i][j][1]);
          
        }
        
        context.fillStyle = "hsla(" + hue + ", 90%, 50%, 0.4)";
        context.fill();
        
        context.strokeStyle = "hsla(" + hue + ", 90%, 50%, 0.5)";
        context.stroke();
        
        // draw points
        
        context.beginPath();
        
        for (i = 0; i < coordinates.length; i++) {
        
          for (j = 0; j < coordinates[i].length; j++) {
            context.moveTo(coordinates[i][j][0] + 2 / scale, coordinates[i][j][1])
            context.arc(coordinates[i][j][0], coordinates[i][j][1], 1 / scale, 0, Math.PI * 2);
          }
          
        }
        
        context.fillStyle = "#f00";
        context.fill();
        
      }
      
      function renderMultiPolygon(context, coordinates, hue, scale) {
        
        var i;
        
        for (i = 0; i < coordinates.length; i++)
          renderPolygon(context, coordinates[i], hue, scale);
        
      }
      
      function renderTile(canvas, data) {
        
        var context = canvas.getContext("2d");
        var scale = canvas.width / data.granularity;
        
        context.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw an outline around the tile
        
        context.lineWidth = 1;
        
        context.strokeStyle = "rgba(255, 255, 255, 0.5)";
        context.strokeRect(0.5, 0.5, canvas.width, canvas.height);
        
        // Set scale for features
        
        context.save();
        context.scale(scale, scale);
        
        context.lineWidth = 2 / scale;
        
        // Iterate over features
        
        data.features.forEach(function(feature) {
          
          // Render feature
          
          var render;
          
          if (feature.geometry.type === "Point")
            render = renderPoint;
          else if (feature.geometry.type === "LineString")
            render = renderLineString;
          else if (feature.geometry.type === "MultiLineString")
            render = renderMultiLineString;
          else if (feature.geometry.type === "Polygon")
            render = renderPolygon;
          else if (feature.geometry.type === "MultiPolygon")
            render = renderMultiPolygon;
          
          render(context, feature.geometry.coordinates, feature.properties.osm_id, scale);
          
        });
        
        // Restore context (is canvas reused?)
        
        context.restore();
        
      }
      
      var canvasTiles = new L.TileLayer.Canvas();

      canvasTiles.drawTile = function(canvas, tilePoint, zoom) {
        
        loadTile(canvas, zoom, tilePoint.x, tilePoint.y);
        
      }
      
      map.addLayer(canvasTiles);
      
    </script>
    
  </body>
</html>
