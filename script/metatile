#!/usr/bin/env ruby
require "rubygems"

$LOAD_PATH << "#{File.dirname(__FILE__)}/../lib"
$LOAD_PATH << "#{File.dirname(__FILE__)}/../vendor"
require "trollop"
require "cover"

options = Trollop::options do
  opt :size, "Metatile size", :type => :integer, :default => 8
  opt :config, "Configuration file", :type => :string, :required => true
  opt :index, "Tile index (z/x/y)", :type => :string, :required => true
end

if ARGV.size != 1
  Trollop::die "must specify an output path for the metatile"
end

options[:output] = ARGV[0]

# check that the metatile size is a power of 2

if (options[:size] & (options[:size] - 1)) != 0
  Trollop::die "metatile size must be a power of 2"
end

# get tile index

options[:index] = begin
  Cover::Index.from_string(options[:index])
rescue ArgumentError
  Trollop::die "invalid tile index"
end

# config file

require File.expand_path(options[:config])
  
if !Cover.config.respond_to?(:maker)
  puts "Config file must assign to Cover.config an object which responds to #maker"
  exit
end

# set up maker

Cover.config.setup

# query each tile in the metatile, storing the results in an array

# TODO: query for entire metatile area first, then get individual
# tiles out of that?

size = options[:size]

z = options[:index].z
mx = options[:index].x & ~(size - 1)
my = options[:index].y & ~(size - 1)

data = []

(mx .. mx + size - 1).each do |x|
  (my .. my + size - 1).each do |y|
    
    index = Cover::Index.new(z, x, y)
    data << Cover.config.maker.render_tile(index)
    
  end
end

# write results to output file

# native byte order is used, since metatiles are not meant
# for transmission over the network?

File.open(options[:output], "wb+") do |f|
  
  f << ["META"].pack("a4")
  f << [size * size, mx, my, z].pack("l4")
  
  offset = 4 + (4 * 4) + (8 * size * size)
  
  data.each do |d|
    f << [offset, d.bytesize].pack("l2")
    offset += d.bytesize
  end
  
  data.each do |d|
    f << d
  end
  
end

# done!

Cover.config.teardown
