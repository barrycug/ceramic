#!/usr/bin/env ruby
require "rubygems"
require "sqlite3"
require "yaml"

$LOAD_PATH << "./#{File.dirname(__FILE__)}/../lib"
$LOAD_PATH << "./#{File.dirname(__FILE__)}/../vendor"
require "trollop"
require "cover"

options = Trollop::options do
  opt :config, "Configuration file", :type => :string, :required => true
  opt :tiles, "Tile list", :type => :string, :required => true
end

options[:output] = ARGV[0]

if options[:output] == nil
  Trollop::die "must specify an output file"
end

# Get list of tile indices

indices = []

File.open(options[:tiles], "r") do |f|
  f.each_line do |line|
    if line =~ /(\d+\/\d+\/\d+)/
      indices << Cover::Index.from_string($1)
    end
  end
end

# Set up maker

config = YAML.load(File.read(options[:config]))

connection = PG.connect(config["connection"])

maker = Cover::Maker.new(granularity: config["granularity"])

config["sources"].each do |source|
  
  source = Cover::Sources::PostGIS.new(
    connection: connection,
    table: source["table"],
    srid: source["srid"],
    geometry_column: source["geometry_column"],
    type: source["type"].to_sym
  )
  
  maker.sources << source
  
end

# Write the tileset

database = SQLite3::Database.new(options[:output])

tileset = Cover::Tileset.new(database)

tileset.create_schema
tileset.set_metadata(config["metadata"].merge(format: "js"))

indices.each do |index|
  tileset.insert_tile(index, maker.render_tile(index))
end

tileset.optimize

database.close
